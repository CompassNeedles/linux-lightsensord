diff --git a/flo-kernel/arch/arm/include/asm/unistd.h b/flo-kernel/arch/arm/include/asm/unistd.h
index 512cd14..51e1468 100644
--- a/flo-kernel/arch/arm/include/asm/unistd.h
+++ b/flo-kernel/arch/arm/include/asm/unistd.h
@@ -404,6 +404,12 @@
 #define __NR_setns			(__NR_SYSCALL_BASE+375)
 #define __NR_process_vm_readv		(__NR_SYSCALL_BASE+376)
 #define __NR_process_vm_writev		(__NR_SYSCALL_BASE+377)
+#define __NR_set_light_intensity        (__NR_SYSCALL_BASE+378)
+#define __NR_get_light_intensity        (__NR_SYSCALL_BASE+379)
+#define __NR_light_evt_create           (__NR_SYSCALL_BASE+380)
+#define __NR_light_evt_wait             (__NR_SYSCALL_BASE+381)
+#define __NR_light_evt_signal           (__NR_SYSCALL_BASE+382)
+#define __NR_light_evt_destroy          (__NR_SYSCALL_BASE+383)
 
 /*
  * The following SWIs are ARM private.
diff --git a/flo-kernel/arch/arm/kernel/calls.S b/flo-kernel/arch/arm/kernel/calls.S
index 463ff4a..ae08857 100644
--- a/flo-kernel/arch/arm/kernel/calls.S
+++ b/flo-kernel/arch/arm/kernel/calls.S
@@ -387,6 +387,12 @@
 /* 375 */	CALL(sys_setns)
 		CALL(sys_process_vm_readv)
 		CALL(sys_process_vm_writev)
+		CALL(sys_set_light_intensity)
+		CALL(sys_get_light_intensity)
+/* 380 */	CALL(sys_light_evt_create)
+		CALL(sys_light_evt_wait)
+		CALL(sys_light_evt_signal)
+		CALL(sys_light_evt_destroy)
 #ifndef syscalls_counted
 .equ syscalls_padding, ((NR_syscalls + 3) & ~3) - NR_syscalls
 #define syscalls_counted
diff --git a/flo-kernel/include/linux/light.h b/flo-kernel/include/linux/light.h
new file mode 100644
index 0000000..ac0bea3
--- /dev/null
+++ b/flo-kernel/include/linux/light.h
@@ -0,0 +1,59 @@
+#ifndef _LIGHT_H
+#define _LIGHT_H
+
+#include <linux/list.h>
+#include <linux/wait.h>
+
+#define MAX_LI  3276800
+#define NOISE   20
+#define WINDOW  20
+
+/*
+	Use this wrapper to pass the intensity to your system call
+*/
+struct light_intensity {
+	int cur_intensity;
+};
+
+/*
+	An event triggers if:
+	1.  A sensor reading of > 'req_intensity' - NOISE occurs,
+	2.  at least 'frequency' number of times in the TIME_INTERVAL
+		defined in userspace. Only the user passing on frequency
+		to the kernel knows TIME_INTERVAL. The kernel does not
+		care about this value.
+*/
+struct event_requirements {
+	int req_intensity;
+	int frequency;
+};
+
+/*
+	Data members for an event object:
+	struct ev {
+		.id: id allocated to this user-created event (in FI order)
+		.reqs: event_requirements for this user-created event; thresholds
+			that make it trigger, hence waking all processes waiting
+			on this event
+		.head: list_head entry, in "global" list of user-created events,
+			also used as iterator
+		.queue: reference to wait queue struct from wait.h dedicated to this
+			event, on which all userspace processes waiting to be woken
+			will be attached, as a list_head entry
+		.no_satisfaction: indicates that the event requirements have not
+			yet been met
+		.destroyed: used to signal event is destroyed
+		.ref_count: used to signal when the event is safe to destroy
+	}
+*/
+struct ev {
+	int id;
+	struct event_requirements reqs;
+	struct list_head ev_h;
+	wait_queue_head_t queue;
+	int no_satisfaction;
+	int destroyed;
+	int ref_count;
+};
+
+#endif
diff --git a/flo-kernel/include/linux/syscalls.h b/flo-kernel/include/linux/syscalls.h
index 3de3acb..1382a35 100644
--- a/flo-kernel/include/linux/syscalls.h
+++ b/flo-kernel/include/linux/syscalls.h
@@ -76,6 +76,7 @@ struct file_handle;
 #include <linux/quota.h>
 #include <linux/key.h>
 #include <trace/syscall.h>
+#include <linux/light.h>
 
 #define __SC_DECL1(t1, a1)	t1 a1
 #define __SC_DECL2(t2, a2, ...) t2 a2, __SC_DECL1(__VA_ARGS__)
@@ -202,7 +203,7 @@ extern struct trace_event_functions exit_syscall_print_funcs;
 #ifdef CONFIG_PPC64
 #define SYSCALL_ALIAS(alias, name)					\
 	asm ("\t.globl " #alias "\n\t.set " #alias ", " #name "\n"	\
-	     "\t.globl ." #alias "\n\t.set ." #alias ", ." #name)
+		 "\t.globl ." #alias "\n\t.set ." #alias ", ." #name)
 #else
 #if defined(CONFIG_ALPHA) || defined(CONFIG_MIPS)
 #define SYSCALL_ALIAS(alias, name)					\
@@ -430,21 +431,21 @@ asmlinkage long sys_ftruncate64(unsigned int fd, loff_t length);
 #endif
 
 asmlinkage long sys_setxattr(const char __user *path, const char __user *name,
-			     const void __user *value, size_t size, int flags);
+				 const void __user *value, size_t size, int flags);
 asmlinkage long sys_lsetxattr(const char __user *path, const char __user *name,
-			      const void __user *value, size_t size, int flags);
+				  const void __user *value, size_t size, int flags);
 asmlinkage long sys_fsetxattr(int fd, const char __user *name,
-			      const void __user *value, size_t size, int flags);
+				  const void __user *value, size_t size, int flags);
 asmlinkage long sys_getxattr(const char __user *path, const char __user *name,
-			     void __user *value, size_t size);
+				 void __user *value, size_t size);
 asmlinkage long sys_lgetxattr(const char __user *path, const char __user *name,
-			      void __user *value, size_t size);
+				  void __user *value, size_t size);
 asmlinkage long sys_fgetxattr(int fd, const char __user *name,
-			      void __user *value, size_t size);
+				  void __user *value, size_t size);
 asmlinkage long sys_listxattr(const char __user *path, char __user *list,
-			      size_t size);
+				  size_t size);
 asmlinkage long sys_llistxattr(const char __user *path, char __user *list,
-			       size_t size);
+				   size_t size);
 asmlinkage long sys_flistxattr(int fd, char __user *list, size_t size);
 asmlinkage long sys_removexattr(const char __user *path,
 				const char __user *name);
@@ -511,11 +512,11 @@ asmlinkage long sys_io_getevents(aio_context_t ctx_id,
 asmlinkage long sys_io_submit(aio_context_t, long,
 				struct iocb __user * __user *);
 asmlinkage long sys_io_cancel(aio_context_t ctx_id, struct iocb __user *iocb,
-			      struct io_event __user *result);
+				  struct io_event __user *result);
 asmlinkage long sys_sendfile(int out_fd, int in_fd,
-			     off_t __user *offset, size_t count);
+				 off_t __user *offset, size_t count);
 asmlinkage long sys_sendfile64(int out_fd, int in_fd,
-			       loff_t __user *offset, size_t count);
+				   loff_t __user *offset, size_t count);
 asmlinkage long sys_readlink(const char __user *path,
 				char __user *buf, int bufsiz);
 asmlinkage long sys_creat(const char __user *pathname, umode_t mode);
@@ -575,13 +576,13 @@ asmlinkage long sys_writev(unsigned long fd,
 			   const struct iovec __user *vec,
 			   unsigned long vlen);
 asmlinkage long sys_pread64(unsigned int fd, char __user *buf,
-			    size_t count, loff_t pos);
+				size_t count, loff_t pos);
 asmlinkage long sys_pwrite64(unsigned int fd, const char __user *buf,
-			     size_t count, loff_t pos);
+				 size_t count, loff_t pos);
 asmlinkage long sys_preadv(unsigned long fd, const struct iovec __user *vec,
 			   unsigned long vlen, unsigned long pos_l, unsigned long pos_h);
 asmlinkage long sys_pwritev(unsigned long fd, const struct iovec __user *vec,
-			    unsigned long vlen, unsigned long pos_l, unsigned long pos_h);
+				unsigned long vlen, unsigned long pos_l, unsigned long pos_h);
 asmlinkage long sys_getcwd(char __user *buf, unsigned long size);
 asmlinkage long sys_mkdir(const char __user *pathname, umode_t mode);
 asmlinkage long sys_chdir(const char __user *filename);
@@ -612,14 +613,14 @@ asmlinkage long sys_sendto(int, void __user *, size_t, unsigned,
 				struct sockaddr __user *, int);
 asmlinkage long sys_sendmsg(int fd, struct msghdr __user *msg, unsigned flags);
 asmlinkage long sys_sendmmsg(int fd, struct mmsghdr __user *msg,
-			     unsigned int vlen, unsigned flags);
+				 unsigned int vlen, unsigned flags);
 asmlinkage long sys_recv(int, void __user *, size_t, unsigned);
 asmlinkage long sys_recvfrom(int, void __user *, size_t, unsigned,
 				struct sockaddr __user *, int __user *);
 asmlinkage long sys_recvmsg(int fd, struct msghdr __user *msg, unsigned flags);
 asmlinkage long sys_recvmmsg(int fd, struct mmsghdr __user *msg,
-			     unsigned int vlen, unsigned flags,
-			     struct timespec __user *timeout);
+				 unsigned int vlen, unsigned flags,
+				 struct timespec __user *timeout);
 asmlinkage long sys_socket(int, int, int);
 asmlinkage long sys_socketpair(int, int, int, int __user *);
 asmlinkage long sys_socketcall(int call, unsigned long __user *args);
@@ -710,10 +711,10 @@ asmlinkage long sys_ptrace(long request, long pid, unsigned long addr,
 			   unsigned long data);
 
 asmlinkage long sys_add_key(const char __user *_type,
-			    const char __user *_description,
-			    const void __user *_payload,
-			    size_t plen,
-			    key_serial_t destringid);
+				const char __user *_description,
+				const void __user *_payload,
+				size_t plen,
+				key_serial_t destringid);
 
 asmlinkage long sys_request_key(const char __user *_type,
 				const char __user *_description,
@@ -757,30 +758,30 @@ asmlinkage long sys_spu_create(const char __user *name,
 		unsigned int flags, umode_t mode, int fd);
 
 asmlinkage long sys_mknodat(int dfd, const char __user * filename, umode_t mode,
-			    unsigned dev);
+				unsigned dev);
 asmlinkage long sys_mkdirat(int dfd, const char __user * pathname, umode_t mode);
 asmlinkage long sys_unlinkat(int dfd, const char __user * pathname, int flag);
 asmlinkage long sys_symlinkat(const char __user * oldname,
-			      int newdfd, const char __user * newname);
+				  int newdfd, const char __user * newname);
 asmlinkage long sys_linkat(int olddfd, const char __user *oldname,
 			   int newdfd, const char __user *newname, int flags);
 asmlinkage long sys_renameat(int olddfd, const char __user * oldname,
-			     int newdfd, const char __user * newname);
+				 int newdfd, const char __user * newname);
 asmlinkage long sys_futimesat(int dfd, const char __user *filename,
-			      struct timeval __user *utimes);
+				  struct timeval __user *utimes);
 asmlinkage long sys_faccessat(int dfd, const char __user *filename, int mode);
 asmlinkage long sys_fchmodat(int dfd, const char __user * filename,
-			     umode_t mode);
+				 umode_t mode);
 asmlinkage long sys_fchownat(int dfd, const char __user *filename, uid_t user,
-			     gid_t group, int flag);
+				 gid_t group, int flag);
 asmlinkage long sys_openat(int dfd, const char __user *filename, int flags,
 			   umode_t mode);
 asmlinkage long sys_newfstatat(int dfd, const char __user *filename,
-			       struct stat __user *statbuf, int flag);
+				   struct stat __user *statbuf, int flag);
 asmlinkage long sys_fstatat64(int dfd, const char __user *filename,
-			       struct stat64 __user *statbuf, int flag);
+				   struct stat64 __user *statbuf, int flag);
 asmlinkage long sys_readlinkat(int dfd, const char __user *path, char __user *buf,
-			       int bufsiz);
+				   int bufsiz);
 asmlinkage long sys_utimensat(int dfd, const char __user *filename,
 				struct timespec __user *utimes, int flags);
 asmlinkage long sys_unshare(unsigned long unshare_flags);
@@ -790,34 +791,34 @@ asmlinkage long sys_splice(int fd_in, loff_t __user *off_in,
 			   size_t len, unsigned int flags);
 
 asmlinkage long sys_vmsplice(int fd, const struct iovec __user *iov,
-			     unsigned long nr_segs, unsigned int flags);
+				 unsigned long nr_segs, unsigned int flags);
 
 asmlinkage long sys_tee(int fdin, int fdout, size_t len, unsigned int flags);
 
 asmlinkage long sys_sync_file_range(int fd, loff_t offset, loff_t nbytes,
 					unsigned int flags);
 asmlinkage long sys_sync_file_range2(int fd, unsigned int flags,
-				     loff_t offset, loff_t nbytes);
+					 loff_t offset, loff_t nbytes);
 asmlinkage long sys_get_robust_list(int pid,
-				    struct robust_list_head __user * __user *head_ptr,
-				    size_t __user *len_ptr);
+					struct robust_list_head __user * __user *head_ptr,
+					size_t __user *len_ptr);
 asmlinkage long sys_set_robust_list(struct robust_list_head __user *head,
-				    size_t len);
+					size_t len);
 asmlinkage long sys_getcpu(unsigned __user *cpu, unsigned __user *node, struct getcpu_cache __user *cache);
 asmlinkage long sys_signalfd(int ufd, sigset_t __user *user_mask, size_t sizemask);
 asmlinkage long sys_signalfd4(int ufd, sigset_t __user *user_mask, size_t sizemask, int flags);
 asmlinkage long sys_timerfd_create(int clockid, int flags);
 asmlinkage long sys_timerfd_settime(int ufd, int flags,
-				    const struct itimerspec __user *utmr,
-				    struct itimerspec __user *otmr);
+					const struct itimerspec __user *utmr,
+					struct itimerspec __user *otmr);
 asmlinkage long sys_timerfd_gettime(int ufd, struct itimerspec __user *otmr);
 asmlinkage long sys_eventfd(unsigned int count);
 asmlinkage long sys_eventfd2(unsigned int count, int flags);
 asmlinkage long sys_fallocate(int fd, int mode, loff_t offset, loff_t len);
 asmlinkage long sys_old_readdir(unsigned int, struct old_linux_dirent __user *, unsigned int);
 asmlinkage long sys_pselect6(int, fd_set __user *, fd_set __user *,
-			     fd_set __user *, struct timespec __user *,
-			     void __user *);
+				 fd_set __user *, struct timespec __user *,
+				 void __user *);
 asmlinkage long sys_ppoll(struct pollfd __user *, unsigned int,
 			  struct timespec __user *, const sigset_t __user *,
 			  size_t);
@@ -839,23 +840,34 @@ asmlinkage long sys_mmap_pgoff(unsigned long addr, unsigned long len,
 			unsigned long fd, unsigned long pgoff);
 asmlinkage long sys_old_mmap(struct mmap_arg_struct __user *arg);
 asmlinkage long sys_name_to_handle_at(int dfd, const char __user *name,
-				      struct file_handle __user *handle,
-				      int __user *mnt_id, int flag);
+					  struct file_handle __user *handle,
+					  int __user *mnt_id, int flag);
 asmlinkage long sys_open_by_handle_at(int mountdirfd,
-				      struct file_handle __user *handle,
-				      int flags);
+					  struct file_handle __user *handle,
+					  int flags);
 asmlinkage long sys_setns(int fd, int nstype);
 asmlinkage long sys_process_vm_readv(pid_t pid,
-				     const struct iovec __user *lvec,
-				     unsigned long liovcnt,
-				     const struct iovec __user *rvec,
-				     unsigned long riovcnt,
-				     unsigned long flags);
+					 const struct iovec __user *lvec,
+					 unsigned long liovcnt,
+					 const struct iovec __user *rvec,
+					 unsigned long riovcnt,
+					 unsigned long flags);
 asmlinkage long sys_process_vm_writev(pid_t pid,
-				      const struct iovec __user *lvec,
-				      unsigned long liovcnt,
-				      const struct iovec __user *rvec,
-				      unsigned long riovcnt,
-				      unsigned long flags);
+					  const struct iovec __user *lvec,
+					  unsigned long liovcnt,
+					  const struct iovec __user *rvec,
+					  unsigned long riovcnt,
+					  unsigned long flags);
+
+asmlinkage long sys_set_light_intensity(struct light_intensity __user
+					*user_light_intensity);
+asmlinkage long sys_get_light_intensity(struct light_intensity __user
+					*user_light_intensity);
+asmlinkage long sys_light_evt_create(struct event_requirements __user
+					*intensity_params);
+asmlinkage long sys_light_evt_wait(int event_id);
+asmlinkage long sys_light_evt_signal(struct light_intensity __user
+					*user_light_intensity);
+asmlinkage long sys_light_evt_destroy(int event_id);
 
 #endif
diff --git a/flo-kernel/kernel/light.c b/flo-kernel/kernel/light.c
new file mode 100644
index 0000000..15f5bb1
--- /dev/null
+++ b/flo-kernel/kernel/light.c
@@ -0,0 +1,438 @@
+#include <linux/light.h>
+#include <linux/syscalls.h>
+#include <linux/poll.h>
+#include <linux/slab.h>
+
+static struct light_intensity k_li = {
+	.cur_intensity = 0,
+};
+
+static struct list_head *events = NULL;
+#define get_event(v)        container_of(v, struct ev, ev_h)
+
+static struct light_intensity li_buf[WINDOW];
+static int curr = 0;
+static int nr_readings = 0;
+
+DEFINE_SPINLOCK(li_lock);
+DEFINE_SPINLOCK(ev_lock);
+DEFINE_SPINLOCK(bf_lock);
+
+/*
+ * Set current ambient intensity in the kernel.
+ *
+ * The parameter user_light_intensity is the pointer to the address
+ * where the sensor data is stored in user space. Follow system call
+ * convention to return 0 on success and the appropriate error value
+ * on failure.
+ *
+ * syscall number 378
+ */
+SYSCALL_DEFINE1(set_light_intensity, struct light_intensity __user *,
+	user_light_intensity)
+{
+	if (get_current_user()->uid != 0)
+		return -EACCES;
+
+	if (user_light_intensity == NULL)
+		return -EINVAL;
+
+	if (user_light_intensity->cur_intensity <= 0 ||
+		user_light_intensity->cur_intensity > MAX_LI)
+		return -EINVAL;
+
+
+	spin_lock(&li_lock);
+	if (copy_from_user(&k_li, user_light_intensity, 
+			sizeof(struct light_intensity))) {
+
+		spin_unlock(&li_lock);
+		return -EFAULT;
+	}
+
+	spin_unlock(&li_lock);
+	return 0;
+}
+
+/*
+ * Retrieve the scaled intensity set in the kernel.
+ *
+ * The same convention as the previous system call but
+ * you are reading the value that was just set.
+ * Handle error cases appropriately and return values according
+ * to convention.
+ * The calling process should provide memory in userspace
+ * to return the intensity.
+ *
+ * syscall number 379
+ */
+SYSCALL_DEFINE1(get_light_intensity, struct light_intensity __user *,
+	user_light_intensity)
+{
+	if (!user_light_intensity)
+		return -EINVAL;
+
+	spin_lock(&li_lock);
+	if (copy_to_user(user_light_intensity, &k_li,
+			sizeof(struct light_intensity))) {
+
+		spin_unlock(&li_lock);
+		return -EFAULT;
+	}
+
+	spin_unlock(&li_lock);
+	return 0;
+}
+
+/*
+ * Create an event based on light intensity.
+ *
+ * If frequency exceeds WINDOW, cap it at WINDOW.
+ * Return an event_id on success and the appropriate error on failure.
+ *
+ * system call number 380
+ */
+SYSCALL_DEFINE1(light_evt_create, struct event_requirements *, intensity_params)
+{
+	int retval = 0;
+	struct ev *ev;
+
+	if (!intensity_params)
+		return -EINVAL;
+
+	ev = kmalloc(sizeof(*ev), GFP_KERNEL);
+
+	if (!ev)
+		return -ENOMEM;
+
+	if (copy_from_user(&ev->reqs, intensity_params,
+		sizeof(struct event_requirements))) {
+		kfree(ev);
+		return -EFAULT;
+	}
+
+	if (ev->reqs.req_intensity  <=  0       ||
+		ev->reqs.req_intensity  >   MAX_LI  ||
+		ev->reqs.frequency      <=  0       ){
+		kfree(ev);
+		return -EINVAL;
+	}
+
+	if (ev->reqs.frequency      >   WINDOW) /* Cap at WINDOW */
+		ev->reqs.frequency = WINDOW;
+
+	if (events)
+		ev->id = get_event(events)->id + 1;
+	else
+		ev->id = 1;
+	retval = ev->id;
+	INIT_LIST_HEAD(&ev->ev_h);
+	init_waitqueue_head(&ev->queue);
+	ev->no_satisfaction = 1;
+	ev->destroyed = 0;
+	ev->ref_count = 0;
+
+	spin_lock(&ev_lock);
+	if (events)
+		list_add_tail(&ev->ev_h, events);
+	events = &ev->ev_h;
+	spin_unlock(&ev_lock);
+
+	return retval;
+}
+
+static inline struct list_head *search_event_by_id(int event_id)
+{
+	struct list_head *v = events;
+
+	if (!v)
+		return ERR_PTR(-EINVAL); /* None created */
+
+	spin_lock(&ev_lock); /* Reading (i.e. reader) must be exclusive */
+
+	while(get_event(v)->id != event_id) {
+		v = v->next;
+
+		if (v == events) {
+			spin_unlock(&ev_lock);
+			return ERR_PTR(-EINVAL); /* Iterated through entire list */
+
+		} else if (!v) {
+			printk(KERN_EMERG "One of the created events is NULL.\n");
+			spin_unlock(&ev_lock);
+			return ERR_PTR(-EFAULT);
+		}
+	}
+	return v;
+}
+
+/*
+ * Destroy an event using the event_id.
+ *
+ * Return 0 on success and the appropriate error on failure.
+ *
+ * system call number 383
+ */
+SYSCALL_DEFINE1(light_evt_destroy, int, event_id)
+{
+	struct ev *ev;
+	struct list_head *v = search_event_by_id(event_id);
+
+	if (IS_ERR(v)) {
+		printk("Destroy event not found; returning %li.\n", PTR_ERR(v));
+		return PTR_ERR(v);
+	}
+
+	if (events == v) {
+		if (!list_empty(v)) {
+			events = events->next;
+		} else {
+			events = NULL;
+		}
+	}
+	list_del(v);
+	spin_unlock(&ev_lock);
+	/* The event has been removed from the "global" list and can no
+	 * longer be accessed by other callers. Next and prev have been
+	 * been put off but the pointer value itself is not changed.
+	 */
+
+	ev = get_event(v);
+	/* printk("Waking up processes on queue of destroyed event.\n"); */
+	ev->destroyed = 1;
+	wake_up_all(&ev->queue);
+	/* printk("Woken up.\n"); */
+	return 0;
+}
+
+static inline int do_wait(struct ev *ev)
+{
+	int retval = 1;
+
+	/* New wait queue entry - works just like list_head. */
+	DEFINE_WAIT(w);
+	ev->ref_count++;
+
+	while (ev->no_satisfaction && !ev->destroyed) {
+		prepare_to_wait(&ev->queue, &w, TASK_INTERRUPTIBLE);
+		if (retval)
+			retval = 0;
+
+		if (signal_pending(current)) {
+			retval = -EINTR;
+			break;
+		}
+
+		/* printk("Putting to sleep, evt_id[%i].\n", ev->id); */
+		spin_unlock(&ev_lock); /* Unlock before sleep */
+		schedule();
+		spin_lock(&ev_lock); /* Lock while reading event */
+		/* printk("Checking condition, evt_id[%i].\n", ev->id); */
+	}
+
+	/* With the process being released, decrease the number of references
+	 * to the event. */
+	ev->ref_count--;
+
+	if (retval < 1)
+		finish_wait(&ev->queue, &w); /* Else never queued */
+	else
+		retval = 0; /* Reset to turn into valid return value */
+
+	if (ev->ref_count <= 0)
+		ev->no_satisfaction = 1; /* Event is free */
+
+	/* Ref count should never become negative. To be on the safe side
+	 * it's preferable to cover the entire range of possible values. */
+	if (ev->ref_count <= 0 && ev->destroyed) {
+		/* printk("Destroying, evt_id[%i].\n", ev->id); */
+		kfree(ev); /* Destroy */
+	}
+
+	spin_unlock(&ev_lock);
+	return retval;
+}
+
+/*
+ * Block a process on an event.
+ *
+ * It takes the event_id as parameter. The event_id requires verification.
+ * Return 0 on success and the appropriate error on failure.
+ *
+ * system call number 381
+ */
+SYSCALL_DEFINE1(light_evt_wait, int, event_id)
+{
+	struct list_head *v = search_event_by_id(event_id);
+
+	if (IS_ERR(v)) {
+		printk("Wait event not found; returning %li.\n", PTR_ERR(v));
+		return PTR_ERR(v);
+	}
+
+	return do_wait(get_event(v));
+}
+
+
+/* The kernel has a call table for syscalls into which all these
+ * inline functions can unfold and fit nicely.
+ */
+static inline int do_count(struct event_requirements *reqs)
+{
+	int i = 0, reading, count = reqs->frequency;
+	for ( ; i > -nr_readings; --i) {
+
+		if (curr + i < 0)
+			reading = li_buf[curr + i + WINDOW].cur_intensity;
+		else
+			reading = li_buf[curr + i].cur_intensity;
+
+		if (reading > reqs->req_intensity - NOISE) {
+			if (!--count)
+				return 1;
+		}
+	}
+	/* We could also update largest_event_frequency's req_intensity
+	 * and largest_event_req_intensity's frequency here, if either
+	 * have larger "counterparts".
+	 */
+	return 0;
+}
+
+static inline int update_event_stats(void)
+{
+	int signal_event = 0;
+	struct list_head *v = events;
+	struct ev *ev;
+	struct event_requirements r;
+
+	/* A minor optimization */
+	int largest_event_frequency = 0;
+	int its_req_intensity = 0;
+	int largest_event_req_intensity = 0;
+	int its_frequency = 0;
+
+	spin_lock(&ev_lock);
+
+	while (v) {
+		ev = get_event(v);
+
+		if (!ev) {
+			v = NULL;
+			break;
+		}
+		r = ev->reqs;
+
+		if ((r.req_intensity <= largest_event_req_intensity  &&
+			 r.frequency     <= its_frequency               )||
+			(r.frequency     <= largest_event_frequency      &&
+			 r.req_intensity <= its_req_intensity))
+			signal_event = 1;
+		else
+			signal_event = do_count(&r);
+
+		if (signal_event) {
+
+			ev->no_satisfaction = 0;
+			wake_up_all(&ev->queue);
+
+			if (r.req_intensity <=  largest_event_req_intensity &&
+				r.frequency     >   its_frequency)
+
+				its_frequency = r.frequency;
+
+			if (r.frequency     <=  largest_event_frequency     &&
+				r.req_intensity >   its_req_intensity)
+
+				its_req_intensity = r.req_intensity;
+		}
+
+		v = v->next;
+		if (v == events)
+			break;
+	}
+	spin_unlock(&ev_lock);
+
+	if (!v) {
+		printk(KERN_WARNING "No events found to signal.\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+/* Do not use without holding the li_lock.
+ */
+static inline int update_buffer(int val)
+{
+	int retval;
+	spin_lock(&bf_lock);
+
+	/* How easy would it be to turn this into a fixed size BST */
+	curr = (curr + 1) % WINDOW;
+	li_buf[curr].cur_intensity = val;
+
+	if (nr_readings < WINDOW-1)
+		++nr_readings;
+
+	retval = update_event_stats();
+	/* We want to make sure to update event stats at least once every
+		WINDOW light intensity updates. Otherwise, we may be missing out
+		on events. A minimum frequency of 1 is allowed, and in that
+		case, it is optimal to update stats at every light intensity
+		update. Otherwise, we can use a semaphore initialized to
+		<= WINDOW to update the buffer, ignoring race conditions between
+		event stat (which may cause events to go undetected) and buffer
+		updates. This is a tradeoff.
+	 */
+
+	/* We can unlock before update_event_stats if we copy the buffer and
+		pass it on to update_event_stats (after which we destroy the
+		copy). Overall there is a time-space-accuracy tradeoff between
+		all the different options (this, copying and tuning sampling
+		parameters).
+	 */
+	spin_unlock(&bf_lock);
+	return retval;
+}
+
+/*
+ * The light_evt_signal system call.
+ *
+ * Takes sensor data from user, stores the data in the kernel,
+ * and notifies all open events whose
+ * baseline is surpassed.  All processes waiting on a given event 
+ * are unblocked.
+ *
+ * Return 0 success and the appropriate error on failure.
+ *
+ * system call number 382
+ */
+SYSCALL_DEFINE1(light_evt_signal, struct light_intensity __user *,
+	user_light_intensity)
+{
+	int update_value;
+
+	if (get_current_user()->uid != 0)
+		return -EACCES;
+
+	if (user_light_intensity == NULL)
+		return -EINVAL;
+
+	if (user_light_intensity->cur_intensity <= 0 ||
+		user_light_intensity->cur_intensity > MAX_LI)
+		return -EINVAL;
+
+	spin_lock(&li_lock);
+	update_value = copy_from_user(&k_li, user_light_intensity, 
+			sizeof(struct light_intensity));
+
+	if (update_value) {
+		spin_unlock(&li_lock);
+		return -EFAULT;
+	}
+	update_value = k_li.cur_intensity;
+	spin_unlock(&li_lock);
+
+	return update_buffer(update_value);
+}
diff --git a/light_d/light.h b/light_d/light.h
index ed231ff..ea5d07d 100644
--- a/light_d/light.h
+++ b/light_d/light.h
@@ -2,11 +2,18 @@
 #define _LIGHT_H
 
 /*
-Use this wrapper to pass the intensity to your system call
-*/
+ * Use this wrapper to pass the intensity to your system call
+ */
 
 struct light_intensity{
 	int cur_intensity;
 };
 
+/*
+ * Syscall wrapper functions
+ */
+
+int get(struct light_intensity* user_light_intensity);
+int set(struct light_intensity* user_light_intensity);
+
 #endif
diff --git a/light_d/light_d.c b/light_d/light_d.c
index 91c89af..e9309c5 100755
--- a/light_d/light_d.c
+++ b/light_d/light_d.c
@@ -1,7 +1,7 @@
 /*
  * Columbia University
  * COMS W4118 Fall 2015
- * Homework 3
+ * Extends Homework 3 starter code.
  *
  */
 #include <bionic/errno.h> /* Google does things a little different...*/
@@ -13,49 +13,117 @@
 #include <unistd.h>
 #include <sys/ioctl.h>
 #include <hardware/hardware.h>
-#include <hardware/sensors.h> /* <-- This is a good place to look! */
+#include <hardware/sensors.h>
 #include <errno.h>
 #include <sys/stat.h>
+#include <sys/wait.h>
+#include <sys/signal.h>
+
 #include "../flo-kernel/include/linux/akm8975.h" 
 #include "light.h"
 
-#define EMULATOR 0
-#define DEVICE 1
+#define EMULATOR                    0
+#define DEVICE                      1
+
+#define LIGHT_INTENSITY_SENSOR      5
 
-#define LIGHT_INTENSITY_SENSOR 5
+#define TIME_INTERVAL               5000000
+#define MAX_LI                      3276800
 
-#define __NR_set_light_intensity 378
-#define __NR_light_evt_signal 382
+#define __NR_set_light_intensity    378
+#define __NR_get_light_intensity    379
 
-/* set to 1 for a bit of debug output */
+/* Unused: */
+/* Set to 1 for a bit of debug output */
 #if 1
-	#define dbg(fmt, ...) printf("Accelerometer: " fmt, ## __VA_ARGS__)
+	#define dbg(fmt, ...) printf("LIGHT_D: " fmt, ## __VA_ARGS__)
 #else
 	#define dbg(fmt, ...)
 #endif
 
+
 static int effective_sensor;
 static int cur_device;
 
-/* helper functions which you should use */
+/* helper functions */
 static int open_sensors(struct sensors_module_t **hw_module,
 			struct sensors_poll_device_t **poll_device);
 static void enumerate_sensors(const struct sensors_module_t *sensors);
 static int poll_sensor_data_emulator(void);
 static int poll_sensor_data(struct sensors_poll_device_t *sensors_device);
 
-/* entry point: fill in daemon implementation
-   where indicated */
-
 void daemon_mode()
 {
+	int daemon, parent = getpid();
+
+	printf("Starting new daemon process.\n");
+
+	printf("Forking daemon.\n");
+	daemon = fork();
+
+	if (daemon == -1)
+		printf("Error forking daemon: %s\n", strerror(errno));
+
+	if (daemon > 0) {
+		/* It is the parent exiting that must remit shell command line
+		 * to the user. The child should not continue printing after
+		 * this happens. */
+		daemon = -1;
+		wait(&daemon);
+		printf("Error: parent waited for daemon to terminate.\n");
+		exit(EXIT_FAILURE);
+	}
+
+	daemon = getpid();
+	printf("We got the daemon's pid: %i.\n", daemon);
+	printf("Check by entering on the command line: ps.\n");
+
+	printf("Before closing file descriptors...\n");
+
+	printf("Disable file operations by resetting umask to 0.\n");
+	umask(0);
 
-/* Fill in daemon implementation here */
+	printf("Change working directory to root.\n");
+	if (chdir("/") == -1)
+		printf("Error changing current directory to root: %s\n",
+			strerror(errno));
 
+	printf("Detach from terminal and create independent session with child as\n");
+	printf("session leader and process group leader.\n");
+	if (setsid() == -1)
+		printf("Error setting session ID: %s\n", strerror(errno));
+
+	printf("Killing parent.\n");
+	if (kill(parent, SIGKILL))
+		printf("Error killing parent: %s\n", strerror(errno));
+
+	if (close(0) == -1) {
+		printf("Error closing stdin: %s\n", strerror(errno));
+	}
+	if (close(2) == -1) {
+		printf("Debug closing stderr: %s\n", strerror(errno));
+	}
+	if (close(1) == -1) {
+		printf("Error closing stdout: %s\n", strerror(errno));
+	}
+}
+
+/* Wrappers to syscalls. */
+int get(struct light_intensity* user_light_intensity)
+{
+	return syscall(__NR_get_light_intensity, user_light_intensity);
+}
+
+int set(struct light_intensity* user_light_intensity)
+{
+	return syscall(__NR_set_light_intensity, user_light_intensity);
 }
 
 int main(int argc, char **argv)
 {
+	struct light_intensity val;
+	int retval;
+
 	effective_sensor = -1;
 	cur_device = -1;
 	if (argc != 2) {
@@ -74,9 +142,6 @@ int main(int argc, char **argv)
 
 	struct sensors_module_t *sensors_module = NULL;
 	struct sensors_poll_device_t *sensors_device = NULL;
-	
-	daemon_mode();
-	/* Implement your code to make this process a daemon in daemon_mode function */
 
 	printf("Opening sensors...\n");
 	if (open_sensors(&sensors_module,
@@ -86,14 +151,51 @@ int main(int argc, char **argv)
 	}
 	enumerate_sensors(sensors_module);
 
-	/* Fill in daemon implementation around here */
-	printf("turn me into a daemon!\n");
-	while (1) {
-		
-		poll_sensor_data(sensors_device);
-	}
+	/* Test before daemon mode */
+
+	val.cur_intensity = poll_sensor_data(sensors_device);
+	printf("Polled device with scaled intensity: %i.\n", val.cur_intensity);
+
+	retval = set(&val);
+
+	if (retval)
+		printf("Error[%i] setting: %s.\n", retval, strerror(errno));
+	else
+		printf("Set current light intensity successfully.\n");
+
+	val.cur_intensity = MAX_LI + 1;
+	retval = get(&val);
+
+	if (retval)
+		printf("Error[%i] getting: %s.\n", retval, strerror(errno));
+	else if (val.cur_intensity <= 0 || val.cur_intensity > MAX_LI)
+		printf("Error: got invalid light intensity with value %i.\n",
+			val.cur_intensity);
+	else
+		printf("Got current light intensity successfully with value %i.\n",
+			val.cur_intensity);
+
+	daemon_mode();
+
+	while (1) { /* Success */
+		usleep(TIME_INTERVAL);
 
-	return EXIT_SUCCESS;
+		val.cur_intensity = poll_sensor_data(sensors_device);
+		retval = set(&val);
+
+		if (retval) /* Kill unsuccessful daemon */
+			return EXIT_FAILURE;
+
+		val.cur_intensity = MAX_LI + 1;
+		retval = get(&val);
+
+		if (retval || val.cur_intensity <= 0 || val.cur_intensity > MAX_LI)
+			return EXIT_FAILURE;
+	}
+	/* You will be able to see by doing cat /proc/kmsg that the daemon
+	 * exits with status 1 (EXIT_FAILURE) whereas the parent exits with
+	 * status 0 (EXIT_SUCCESS). Debug in kernel.
+	 */
 }
 
 /*
@@ -103,39 +205,35 @@ int main(int argc, char **argv)
 
 static int poll_sensor_data(struct sensors_poll_device_t *sensors_device)
 {   
-    const size_t numEventMax = 16;
-    const size_t minBufferSize = numEventMax;
-    sensors_event_t buffer[minBufferSize];
-    ssize_t count = sensors_device->poll(sensors_device, buffer, minBufferSize);
-    float cur_intensity = 0;
-	
-
-    int i; 
-      
+	const size_t numEventMax = 16;
+	const size_t minBufferSize = numEventMax;
+	sensors_event_t buffer[minBufferSize];
+	ssize_t count = sensors_device->poll(sensors_device, buffer, minBufferSize);
+	float cur_intensity = 0;
+
+	int i;
 	if (cur_device == DEVICE) {
-		
+		printf("DEVICE\n");
 		for (i = 0; i < count; ++i) {
-                	if (buffer[i].sensor != effective_sensor)
-                        	continue;
-                
-		/* You have the intensity here - scale it and send it to your kernel */
-                
-		cur_intensity = buffer[i].light;
-		printf("%f\n", cur_intensity);	
+			if (buffer[i].sensor != effective_sensor)
+				continue;
+			cur_intensity = buffer[i].light;
+			printf("%f\n", cur_intensity);
 		}
 	}
 
 	else if (cur_device == EMULATOR) {
-
+		printf("EMULATOR\n");
 		/* Same thing again here - pretty bad hack for the emulator */
-		/* Didn't know that the sensor simulator had only temperature but not light */		
+		/* Didn't know that the sensor simulator had only temperature but not light */
 		/* cur_intensity has a floating point value that you would have fed to */
 		/* light_sensor binary */
 		cur_intensity = poll_sensor_data_emulator();
 		printf("%f\n", cur_intensity);
 	}
-	
-	return 0;
+
+	cur_intensity *= 100;
+	return (int)cur_intensity; /* or (int)(cur_intensity + 0.5) */
 }
 
 
@@ -148,14 +246,14 @@ static int poll_sensor_data(struct sensors_poll_device_t *sensors_device)
 static int poll_sensor_data_emulator(void)
 {
 	float cur_intensity;
-        
-        FILE *fp = fopen("/data/misc/intensity", "r");
-        if (!fp)
-                return 0;       
-        
-        fscanf(fp, "%f", &cur_intensity);
-        fclose(fp);
-        return cur_intensity;
+		
+		FILE *fp = fopen("/data/misc/intensity", "r");
+		if (!fp)
+				return 0;       
+		
+		fscanf(fp, "%f", &cur_intensity);
+		fclose(fp);
+		return cur_intensity;
 }
 
 
@@ -166,7 +264,7 @@ static int open_sensors(struct sensors_module_t **mSensorModule,
 {
    
 	int err = hw_get_module(SENSORS_HARDWARE_MODULE_ID,
-				     (hw_module_t const**)mSensorModule);
+					 (hw_module_t const**)mSensorModule);
 
 	if (err) {
 		printf("couldn't load %s module (%s)",
@@ -219,5 +317,5 @@ static void enumerate_sensors(const struct sensors_module_t *sensors)
 		if (slist[s].type == LIGHT_INTENSITY_SENSOR && slist[s].handle == LIGHT_INTENSITY_SENSOR)
 			effective_sensor = LIGHT_INTENSITY_SENSOR; /*the sensor ID*/
 
-                }
+				}
 }
diff --git a/test/test.c b/test/test.c
index 44c8223..e407641 100644
--- a/test/test.c
+++ b/test/test.c
@@ -2,10 +2,175 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <sys/ioctl.h>
+#include <string.h>
+#include <errno.h>
+#include <wait.h>
+
 #include "light.h"
 
+#define TIME_INTERVAL 1000000
+#define LATENT_PERIOD 500000
+
+#define __NR_get_light_intensity    379
+#define __NR_light_evt_create       380
+#define __NR_light_evt_wait         381
+#define __NR_light_evt_signal       382
+#define __NR_light_evt_destroy      383
+
+int get(struct light_intensity *kernel_light_intensity)
+{
+	return syscall(__NR_get_light_intensity, kernel_light_intensity);
+}
+
+int light_evt_create(struct event_requirements *intensity_params)
+{
+	return syscall(__NR_light_evt_create, intensity_params);
+}
+
+int light_evt_wait(int event_id)
+{
+	return syscall(__NR_light_evt_wait, event_id);
+}
+
+int light_evt_signal(struct light_intensity *user_light_intensity)
+{
+	return syscall(__NR_light_evt_signal, user_light_intensity);
+}
+
+int light_evt_destroy(int event_id)
+{
+	return syscall(__NR_light_evt_destroy, event_id);
+}
+
+/* Test:
+ * Quick (and dirty...)... Lacks *unit tests* (and edge cases).
+ */
 int main (void)
 {
-	/* Write your test program here */
+	int child_pid, read, evt_id;
+	struct light_intensity cur_value;
+
+
+	/* Define events and have parent create them in kernel */
+	struct event_requirements A = {500000, 5};
+	struct event_requirements B = {50000, 7};
+	struct event_requirements C = {500, 3};
+
+	int A_id = light_evt_create(&A);
+	if (A_id <= 0) {
+		printf("Error[%i] A: %s.\n", A_id, strerror(errno));
+	} else {
+		printf("Created evt_A_id[%i] for children 0-2 to wait on.\n", A_id);
+	}
+
+	int B_id = light_evt_create(&B);
+	if (B_id <= 0) {
+		printf("Error[%i] B: %s.\n", B_id, strerror(errno));
+	} else {
+		printf("Created evt_B_id[%i] for children 3-5 to wait on.\n", B_id);
+	}
+
+	int C_id = light_evt_create(&C);
+	if (C_id <= 0) {
+		printf("Error[%i] C: %s.\n", C_id, strerror(errno));
+	} else {
+		printf("Created evt_C_id[%i] for children 6-8 to wait on.\n", C_id);
+	}
+
+
+	/* Fork children */
+	int N = 10;
+	int n = 0;
+	int e = 0;
+
+	for ( ; n < N; ++n) {
+		child_pid = fork();
+		if (child_pid == 0) {
+			usleep(LATENT_PERIOD);
+			break;
+		} else
+			printf("Created child[%i] pid[%i].\n", n, child_pid);
+	}
+
+
+	/* Signal poll sensor data, wait on events, print and destroy */
+	printf("PID[%i] executing.\n", getpid());
+
+	while (child_pid == 0) {
+
+		/* Periodically signal */
+		if (n > 8) {
+
+			read = usleep(TIME_INTERVAL);
+			if (read)
+				printf("Error[%i] usleep: %s.\n", read, strerror(errno));
+
+			/* Poll sensor data from kernel.
+			 * Have daemon run simultaneously. */
+			read = get(&cur_value);
+			if (read)
+				printf("Error[%i]: get failure, %s.\n", read, strerror(errno));
+
+			printf("Intensity in kernel: %i.\n", cur_value.cur_intensity);
+
+			/* Signal to kernel */
+			read = light_evt_signal(&cur_value);
+			if (read)
+				printf("Error[%i] signal: %s.\n", read, strerror(errno));
+
+			continue; /* child [9] is only meant to signal */
+
+		} else if (n > 5) {     /* 6,7,8 */
+			evt_id = C_id;
+		} else if (n > 2) {     /* 3,4,5 */
+			evt_id = B_id;
+		} else {                /* 0,1,2 */
+			evt_id = A_id;
+		}
+
+		printf("Making wait on event id: %i.\n", evt_id);
+		read = light_evt_wait(evt_id);
+
+		if (read) {
+			printf("Error[%i] wait on event: %s\n", read, strerror(errno));
+			printf("Child[%i] pid[%i] evt_id[%i].\n", n, getpid(), evt_id);
+			break; /* discontinue tests */
+		} else {
+			printf("Child successfully waited on event.\n");
+			printf("Child[%i] pid[%i] evt_id[%i].\n", n, getpid(), evt_id);
+			++e; /* increment event count */
+		}
+
+		/* At the 9th recorded event for children[0,3,6], destroy */
+		if (e == 9 && ((n % 3) == 0)) {
+			printf("Success: child[%i] pid [%i]: recorded 9 events\n",
+				n, getpid());
+
+			printf("         destroying evt_id[%i]...\n", evt_id);
+			read = light_evt_destroy(evt_id);
+			/* Print later - nest less */
+		}
+
+		if (e < 9 || (n % 3) != 0)
+			continue; /* Do not destroy or display results; keep looping. */
+
+		if (read == 0) {
+			printf("         evt_id[%i] destroyed successfully.\n", evt_id);
+			break;
+		} else {
+			printf("         Error[%i]: %s.\n", read, strerror(errno));
+		}
+		/* Manually sig-interrupt all other children processes if you
+		 * are quick enough.
+		 */
+	}
+	/* Wait for children or weird things happen with the command line */
+	if (child_pid > 0) {
+		n = -1;
+		while (N--)
+			wait(&n);
+	}
+	printf("PID[%i] exiting forever.\n", getpid());
 	return 0;
+	/* The process signaling remains. */
 }
